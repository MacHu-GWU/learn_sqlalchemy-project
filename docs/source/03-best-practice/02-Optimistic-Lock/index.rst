Optimistic Lock
==============================================================================


Overview
------------------------------------------------------------------------------
乐观锁是一种处理在高并发情况下的冲突的策略. 简单来说就是当两个 worker 同时想对一条记录更新时候, 并且这个更新会涉及到先 get, 然后处理, 最后才更新. 也就是说这个更新的业务逻辑的周期比较长, 不是瞬间完成的, 完全有可能期间其他的 worker 把这条记录已经更新了.

与乐观锁对应的策略是悲观锁, 也就是每个 worker 开始干活之前先将这条记录锁上. 这样做是安全了, 但是由于上锁对于数据库来说是有额外的性能开销, 需要隔离和事务进行保证. 在高并发情况下会占用大量数据库资源.

而乐观锁的本质其实没有真正上锁. 它的核心策略是在数据库中加一个单调递增的版本号字段, 例如 version, 值可以是 1, 2, 3, ... worker 干活之前先获得这条记录, 并且获得了当前版本. 干完活之后更新这条记录的时候, 使用 ``UPDATE ... SET version = ${old_version + 1} WHERE id = ${id} AND version = ${old_version}`` 确保只有数据库端的 version 和你之前获得的版本一致才进行更新. 并且这条记录的返回值还会告诉你更新到底有没有发生, 客户端也就能判断这个更新是成功了还是失败了.

注意, 虽然你数据库更新失败了, 但是你的 worker 可是事实在在的干了活的. 在逻辑上, 你更新失败了是应该把干的活页回滚. 但是大量真实世界的业务完美回滚都不容易, 因为你要考虑回滚到一半程序挂了的情况. 如果你的活是会改变外部系统的状态, 并且不能回滚或是回滚不成功的代价很大, 那么你就不应该使用乐观锁策略.

乐观锁还有一个问题是频繁竞争导致浪费了大量时间在竞争上. 比如很多用到了乐观锁的业务实现都会在当更新失败时候, 自动重新 get 再 update 一次. 但是这样其实逻辑上是有问题的, 我们没有说这个活要不要重新干一次. 如果不重新干了, 那是不是你逻辑上就不对了? 因为你是基于别人刚刚更新过的新数据干的活, 跟之前那次的活不一样. 如果重新干, 等于你之前的活白干了, 那么你实际上是浪费了干活的资源. 并且你还要考虑你的活的业务逻辑得满足幂等.

总之乐观锁是一个非常好的并发冲突解决策略, 但是一定要仔细考虑你的应用场景.


Sample Code
------------------------------------------------------------------------------
下面我们有两个程序, ``optimistic_lock_1.py`` 扮演花 10 秒钟干活的程序, ``optimistic_lock_2.py`` 扮演 1 在干活的过程中把记录更新了的情况. 你会发现 10 秒后 worker 1 失败了.

.. dropdown:: optimistic_lock_1.py

    .. literalinclude:: ./optimistic_lock_1.py
       :language: python
       :linenos:

.. dropdown:: optimistic_lock_2.py

    .. literalinclude:: ./optimistic_lock_2.py
       :language: python
       :linenos:
